# ReLearningC

Going deeper into C

# Learning By Reading How To Do C

## Francisco's Interpretation of C Non-Official Docs

| Topic | About | Assignment |
| ----- | ----- | ---------- |
| [Basic Concepts](dl/01) |||
| Comments | C-Style, C++-Style ||
| ASCII | dec, oct, hex, ch | :x: |
| Translation Phases | phases 1, 2, 3, 4, 5, 6, 7, 8 ||
| Identifier, Scope, Lifetime | reserved identifiers; nested, block, file, function, function prototype, and point of declaration scopes; temporary lifetime ||
| Lookup and name spaces | lookup, name spaces ||
| Type | classification, groups, compatibility, composite, incomplete, names | :x: |
| Objects & Alignment | object representation, effective type, strict aliasing, alignment ||
| Arithmetic Types | boolean, character, integer, real floating types, complex floating types, imaginary floating types, range of values | :x: |
| Main Function | parameters, return value ||
| Undefined Behavior | optimization, signed overflow, access out of bounds, uninitialized scalar, invaid scalar, null pointer dereference, access to pointer passed to realloc, infinite loop without side-effects | :x: |
| Memory Model | byte, memory location, threads, data races, memory order ||
| Keywords |||
| Reserved Keywords | keywords not available for redefinition ||
| Underscore Keywords | keywords that begin with an underscore ||
| Preprocessor Specific | pragma ||
| Conditionally Supported | fortran, asm ||
| Preprocessor |||
| Conditional Inclusion | #if, #ifdef, #ifndef, #elif, #else, #endif | :x: |
| Replacing text macros | #define, #undef, #, ##, predefined macros ||
| Other | #include, #error, #pragma, # line ||
| Statements |||
| Intro | labels, expression, compound ||
| Selection | if, switch ||
| Iteration | while, do-while, for ||
| Jump | break, continue, return, goto ||
| Expressions |||
| General | value category, evaluation order, sequence points, constant expressions, implicit conversions, generic selection ||
| Operators | precedence, member access, indirection, logical, comparison, arithmetic, assignment, +/-, function call, comma, conditional, cast ||
| Initialization |||
| Initializations | Explicit, Implicit, Zero ||
| Scalar | initializing a scalar ||
| Array | initializing an array ||
| Structure/Union | struct, union, nested ||
| Declarations ||| 
| Pointers | pointer to objects, functions, and void; null pointers ||
| Array | initialization, constant known size, variabe length, unknown size, qualifiers, array to pointer, multidimensional ||
| Data Structures |  enum, strcut, union, bit field, atomic ||
| States | const, volatile, restrict, alignas ||
| Storage Class Specifiers | duration,linkage, libraries ||
| External & Tentative Defenitions | tentative, one definition rule ||
| Other | typedef, static assert, attributes ||
| Functions |||
| General | defenitions, declarations, variadic arguments, inline, noreturn ||

# Learning By Doing C

## MIT 6.087

| Lecture | About | Problem Set |
| ------- | ----- | ----------- |
| :one: | introduction. writing, compiling, debugging ||
| :two: | variables, datatyoes, operators | :x: |
| :three: | control flow, functions/modular programming, variable scope, static, global variabes | :x: |
| :four: | more control flow, input, output ||
| :five: | pointers, memory addressing, arrays, pointer arithmetic, Strings, searching, sorting |:x:|
| :six: | user-defined datatypes, structs, unions, bitfields, memory allocation, linked lists, binary trees | :x: |
| :seven: | pointers to pointers, string arrays, multidimensional arrays, stacks, queues | :x: |
| :eight: | void, function pointers, hash tables | :x: |
| :nine: | external library, B-trees, priority queues | :x: |
| :ten: | standard library, stdio.h, ctype.h, stdlib.h, assert.h, stdarg.h, time.h | :x: |
| :one::one: | dynamic memory allocation, malloc, valgrind, garbage collection ||
| :one::two: | multithreading, concurrrency | :x: |
| :one::three: | multithreaded programming, sockets, asynchronous I/O ||
| :one::four: | linux inter process communication |:x: |

## Version

The latest version my compiler can interpret
